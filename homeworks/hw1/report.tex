\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{url}
\usepackage{amssymb,amsmath,amsthm}
\usepackage{hyperref}
\usepackage{formal-grammar}
\usepackage{listings}
\usepackage{xcolor}

\begin{document}
    \title{Homework 1 report \\ \large Language Based Technology for Security }
    \author{Niccol√≤ Piazzesi\\n.piazzesi@studenti.unipi.it}
    \maketitle

    \section{Introduction}
    In this report i will describe the general design and implementation choices of  
    the simple functional and mobile language assigned as homework. I will describe the main features  and its semantics, especially how i have handled
    the security aspect of mobile code. In the final section i will also describe some other features that could further extend the power of the language.

    \section{The language}
    \subsection{Syntax}
    The language is basically an extended version of the $\lambda$-calculus, equipped 
    
    with other linguistic construct to ease its use. It features integer and boolean literals,
    artihmetic and logic binary expression, variables and variable bindings, anonymous functions, function application, and a special form of binding to handle named (and possibly recursive) functions.
    The other primitive construct is \textbf{execute} which handles the sandboxed-execution of remote code.
    The abstract syntax of the language can be described with the following formal grammar:
   
    \begin{center}
        \scriptsize
        Aexp := n $\in \mathbb{N}$ | \textbf{Exp} aop \textbf{Eexp}\quad aop $\in \{+,-,*,/\}$ 
        
        \vspace{10pt}
        Bexp := b $\in \{\text{true, false}\}$ | \textbf{Exp} bop \textbf{Exp}\quad bop $\in \{<, >, =\}$ 
        
        \begin{align*}
            Exp:=&\ \text{Aexp} \\
                       &|\  \text{Bexp} \\ 
                       &|\ x,y,...\\
                       &|\ \textbf{if}\ Exp\ \textbf{then }\ Exp\ \textbf{ else}\ Exp \\
                       &|\  \textbf{let}\  x = Exp\ \textbf{in}\ Exp  \\
                       &|\  \textbf{fun}\ x\ -> Exp\\
                       &|\ \textbf{let}\ \textbf{fun}\ f\  x = Exp\ \textbf{in}\ Exp\ \text{(*function definition*)}\\
                       &|\ Exp\ Exp\ \text{(* function application *)} \\
                       &|\ \textbf{execute}\ Exp\ \textbf{allowing}\ [p\ \textbf{s.t}\ p \in \{\text{access(x),execute,binary\_ops}\}]
        \end{align*}

    \end{center}  
To give an example, a possible code to calculate the  factorial of 6 could look like this:
    \begin{lstlisting}[basicstyle=\scriptsize,keywords={let, fun, if,then, else, in }]
        let fun fact n = 
            if n = 0 then
                1
            else 
                fact n*fact n-1
        in 
        fact 6
    \end{lstlisting}
In the concrete language one may imagine to have other higher level linguistic constructs, but for our purpose the syntax shown is more than enough.
\subsection{Basic semantics}

\paragraph{Values}
Each expression gets interpreted to three possible types of value:
\begin{enumerate}
    \item An integer
    \item A boolean 
    \item A closure valure. Closures represent the runtime value of functions, 
    and they keep all the information necessary to access and apply such functions.
\end{enumerate}

\paragraph{Environment}


To handle variable binding and access we need a data structure to track all the mappings.
This is done inside the \textbf{symbol table}. 

A symbol table is essentially an hash table using variable names 
as key to index the variable runtime value. In the implementation the environment is actually made of a list of symbol tables. This is done to handle scoping and variable hiding inside functions. 

\paragraph{Scoping}
Scoping is \textbf{lexical} and the head of the list represent the innermost scoping.
When an expression requires to access a variable, the interpreter scans the list left to right until it finds the first table containing a valid mapping, and returns the value found in that table. 
Each function body is evaluated inside a new scope.

\subsubsection{Arithmetic and boolean expressions}
The semantics of arithmetic and boolean expressions are defined inductively as expected. All the operators take  integer operands. Division is interpreted as \textbf{integer} division, 
meaning that we take the quotient and discard the remainder.

\subsubsection{General basic expressions}

\paragraph{If conditional}
If expression are defined as usual. If the guard condition is true the interpreter evaluates the \textbf{then} branch gets evaluated otherwise it goes to the \textbf{else} branch.

\paragraph{Let bindings}
The interpreter updates the environment with the mapping \textbf{x, exp1} and then evaluates the \textbf{in} expression.

\paragraph{Function declaration}
Anonymous functions simply gets evaluated to their closure, saving the parameter name and capturing the environment.  

Named functions gets evaluated to their closure as well and  the mapping 
\textbf{(f, closure(f))} is saved  before evaluating the \textbf{in} expression. 

Using let bindings we can also bind a name to an anonymous functions but there is a big difference with primitive named functions. In the latter case, the mapping \textbf{(f, closure(f))} is captured in the environment of the function itself, 
meaning that we allow recursive function definition, as seen in the factorial basic example. For anonymous function this is obviously not possible.

\paragraph{Function application}
Function application is defined as usual. The left expression gets evaluated. If it is a closure of a function we apply it passing the evaluated right expression as parameter, producing an error whenever we try to apply any other expression.

\subsection{Execute semantics}

As expected, the most complex part of the language is the handling of mobile code. 
This is done using the primitive \textbf{execute}. Execute takes two parameters: the mobile code to be evaluated and the list of permissions, which represent actions allowed inside the mobile code. 

The list of permission is specified by the receiving end of the remote code and can be of three types: 
\begin{enumerate}
    \item An \textbf{access(x)} permission allows the mobile code to access name x from the surrounding code. This can be used to allow access to 
    private data when x is a variable, but also to  allow calling of function x.

    \item A \textbf{binary\_ops} permission allows the mobile code to perform arithmetic and boolean expression. One could decide to disbale these actions when the lack of control on the data used 
    could cause security issues (e.g an overflow caused by summing two big integers).

    \item The \textbf{execute} permission allows the execute expression to be called from another execute in a restricted way. This should be used very carefully, and as i will explain later is handled in a restricitve way, to prevent security problems. A completely valid alternative 
    would obviously be to never allow nested execution.

\end{enumerate}
As an example, let's say that the mobile code computes the factorial using the user defined function.
The corresponding abstract expression would look like this:
\begin{lstlisting}[basicstyle=\scriptsize,keywords={execute, allowing}]
    execute (fact 5)  allowing [access("fact"), binary_ops]
\end{lstlisting}

By default, \textbf{no} possibly insecure action is allowed. 

The access permission models in an abstract way more concrete permissions. In a concrete language you would have, for example, filesystem read and write permissions and network communication permissions such as \textbf{send} to allow the 
communication of private values.
 In our simple example, these can all be modeled as permissions to access certain function which could be called "read\_file", "write\_file" or "send".

 \subsubsection{Sandbox execution}
 Mobile code gets executed by the interpreter in a special restriced environment, \textbf{a sandbox}. A sandbox is made of three parts:
 \begin{enumerate}
     \item The list of permissions specified by the receiving code .
     \item A reference to the external environment, containing all the name mapping up until the current moment.
     \item A new internal environment, used to store all the new mapping introduced by the mobile code.
 \end{enumerate}
 
 The internal environment is completely fresh and empty at the beginning,not sharing any part with the external one. 
 Evaluation proceeds inside this sandbox and we performs the following checks on security relevant expressions:
 \begin{enumerate}
     \item For variable access, we first check if it exists in the internal environment. If that is not the case, 
     the interpreter checks that access of that name is allowed inside the sandbox. If it is, it proceeds to search the variable mapping in the external environment. If it is not, it raises 
     a security violation.
     \item For binary expressions, we check that arithemtic operations are allowed before evaulating the operands. If not, a security violation is raised.
     \item When an execute expression tries to use another execute, we first check that nested executes are allowed. If they are, the interpreter 
     evaluates the new execute inside a new sandbox. This new sandbox is instantiated with an empty internal environment. The permissions are taken from the first original execute, ignoring the permissions set in the mobile code calling the nested one. 
     This prevents the overwriting of original permissions, avoiding the introduction of possible private data leakage.
 \end{enumerate}

 Allowing nested executions could case other issues, such as non-termination (think of a cyclic execute where some code calls some other remote code that calls the original code  and so on...) but i believe that the presented semantics allows them in a controlled and safer way. 
 As said before, one could argue that the best possible choice is to disable nested executes completely, but i feel that is interesting to think of safe ways to introduce such constructs.

 \section{Possible extensions}

 The language presented is a very simple and minimal one. One could think of various linguistic constructs to enrich it and make it more powerful. 
 Other than more syntactic extensions, i think of two possible extensions, that could make it more safe and secure: 
 \begin{itemize}
     \item \textbf{Code signature}. Mobile code could be signed with a cryptographic key, and an interpreter could reject code that it does not trust entirely. 
     \item \textbf{Type system}. A very basic type system could be added, which  would prevent many wrong expressions to be evaluated. 

 \end{itemize}
 A more advanced solution,based on type systems (and formal logic in general), but out of scope for our simple example,  could be \textbf{proof carrying code}\cite{necula1997proof}.

 The basic idea is the following: the host system  can determine if it safe to execute untrusted code. To do this, the untrusted code must also 
 send a \emph{proof} that states that the code satisfies a certain security policy specified by the host system itself. The system can then check that the proof is valid before executing the code.
\bibliographystyle{unsrt}
 \bibliography{bib}
\end{document}
